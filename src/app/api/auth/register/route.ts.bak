import { logger } from '@/lib/logger';
import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { hashPassword } from '@/lib/password';
import { generateToken, createEmailVerificationExpiry } from '@/lib/token';
import { registerSchema } from '@/lib/validation';
import { successResponse, errorResponse, ERROR_CODES } from '@/lib/api-response';
import { sendVerificationEmail } from '@/lib/email';
import { authRateLimiter } from '@/lib/rate-limit';
import { requireCsrfToken } from '@/lib/csrf';

/**
 * POST /api/auth/register
 * Register a new user account
 */
export async function POST(request: NextRequest) {
  try {
    // CSRF protection
    await requireCsrfToken(request);

    // Rate limiting
    const identifier = request.ip || 'unknown';
    const rateLimitResult = await authRateLimiter.check(identifier);

    if (!rateLimitResult.allowed) {
      return errorResponse(
        ERROR_CODES.RATE_LIMIT_EXCEEDED,
        'Too many registration attempts. Please try again later.',
        429
      );
    }

    // Parse and validate request body
    const body = await request.json();
    const validationResult = registerSchema.safeParse(body);

    if (!validationResult.success) {
      return errorResponse(
        ERROR_CODES.VALIDATION_ERROR,
        validationResult.error.issues[0].message,
        400
      );
    }

    const { email, password } = validationResult.data;

    // Check if user already exists (case-insensitive)
    const existingUser = await prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    });

    if (existingUser) {
      return errorResponse(
        'EMAIL_EXISTS',
        'This email is already registered. Please login or use a different email.',
        409
      );
    }

    // Hash password
    const passwordHash = await hashPassword(password);

    // Create user with related records in a transaction
    const user = await prisma.$transaction(async (tx) => {
      // Create user
      const newUser = await tx.user.create({
        data: {
          email: email.toLowerCase(),
          passwordHash,
          emailVerified: false,
          failedLoginCount: 0,
        },
      });

      // Create verification token
      const verificationToken = generateToken(32);
      await tx.verificationToken.create({
        data: {
          userId: newUser.id,
          token: verificationToken,
          type: 'EMAIL_VERIFICATION',
          expiresAt: createEmailVerificationExpiry(),
        },
      });

      // Create initial quota (500 AI interactions)
      const resetAt = new Date();
      resetAt.setMonth(resetAt.getMonth() + 1); // Reset in 1 month

      await tx.quota.create({
        data: {
          userId: newUser.id,
          aiInteractions: 500,
          resetAt,
        },
      });

      // Create user preferences with default locale
      await tx.userPreference.create({
        data: {
          userId: newUser.id,
          uiLocale: 'en',
          explainLocale: 'en',
        },
      });

      // Send verification email (async, don't wait)
      sendVerificationEmail(email, verificationToken).catch((error) => {
        logger.error('Failed to send verification email:', error);
      });

      return newUser;
    });

    // Return user data (without password hash)
    const { passwordHash: _, ...userData } = user;

    return successResponse(
      {
        user: userData,
        message: 'Registration successful. Please check your email to verify your account.',
      },
      201
    );
  } catch (error) {
    logger.error('Registration error:', error);
    return errorResponse(
      ERROR_CODES.INTERNAL_ERROR,
      'An error occurred during registration. Please try again.',
      500
    );
  }
}
