import { logger } from '@/lib/logger';
import { NextRequest } from 'next/server';
import { prisma } from '@/lib/prisma';
import { verifyPassword } from '@/lib/password';
import { loginSchema } from '@/lib/validation';
import { successResponse, errorResponse, ERROR_CODES } from '@/lib/api-response';
import { authRateLimiter } from '@/lib/rate-limit';
import { createClient } from '@/lib/supabase/server';
import { SignJWT } from 'jose';
import { cookies } from 'next/headers';

import { requireCsrfToken } from '@/lib/csrf';
/**
 * POST /api/auth/login
 * Authenticate a user and create a session
 */
export async function POST(request: NextRequest) {
    // CSRF protection
    await requireCsrfToken(request);

  try {
    // Rate limiting
    const identifier = request.ip || 'unknown';
    const rateLimitResult = await authRateLimiter.check(identifier);

    if (!rateLimitResult.allowed) {
      return errorResponse(
        ERROR_CODES.RATE_LIMIT_EXCEEDED,
        'Too many login attempts. Please try again later.',
        429
      );
    }

    // Parse and validate request body
    const body = await request.json();
    const validationResult = loginSchema.safeParse(body);

    if (!validationResult.success) {
      return errorResponse(
        ERROR_CODES.VALIDATION_ERROR,
        validationResult.error.issues[0].message,
        400
      );
    }

    const { email, password, rememberMe = false } = validationResult.data;

    // Find user (case-insensitive email)
    const user = await prisma.user.findUnique({
      where: { email: email.toLowerCase() },
    });

    // Generic error message to prevent email enumeration
    const invalidCredentialsMessage = 'Invalid email or password.';

    if (!user) {
      return errorResponse(ERROR_CODES.INVALID_CREDENTIALS, invalidCredentialsMessage, 401);
    }

    // Check if account is locked
    if (user.lockedUntil && user.lockedUntil > new Date()) {
      const minutesRemaining = Math.ceil((user.lockedUntil.getTime() - Date.now()) / 60000);
      return errorResponse(
        ERROR_CODES.ACCOUNT_LOCKED,
        `Account is locked due to too many failed login attempts. Please try again in ${minutesRemaining} minutes.`,
        403
      );
    }

    // Verify password
    const isPasswordValid = await verifyPassword(password, user.passwordHash);

    if (!isPasswordValid) {
      // Increment failed login count
      const failedCount = user.failedLoginCount + 1;
      const updateData: { failedLoginCount: number; lockedUntil?: Date } = {
        failedLoginCount: failedCount,
      };

      // Lock account after 5 failed attempts (30 minutes)
      if (failedCount >= 5) {
        const lockedUntil = new Date();
        lockedUntil.setMinutes(lockedUntil.getMinutes() + 30);
        updateData.lockedUntil = lockedUntil;
      }

      await prisma.user.update({
        where: { id: user.id },
        data: updateData,
      });

      if (failedCount >= 5) {
        return errorResponse(
          ERROR_CODES.ACCOUNT_LOCKED,
          'Too many failed login attempts. Your account has been locked for 30 minutes.',
          403
        );
      }

      return errorResponse(ERROR_CODES.INVALID_CREDENTIALS, invalidCredentialsMessage, 401);
    }

    // Check if email is verified (CRITICAL #5)
    if (!user.emailVerified) {
      return errorResponse(
        ERROR_CODES.EMAIL_NOT_VERIFIED,
        'Please verify your email before logging in.',
        403
      );
    }

    // Password is valid - reset failed login count
    await prisma.user.update({
      where: { id: user.id },
      data: {
        failedLoginCount: 0,
        lockedUntil: null,
      },
    });

    // Create JWT session token
    const secret = new TextEncoder().encode(process.env.SESSION_SECRET || 'default-secret-change-me');
    const maxAge = rememberMe ? 30 * 24 * 60 * 60 : 7 * 24 * 60 * 60; // 30 days or 7 days

    const token = await new SignJWT({ userId: user.id })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime(Math.floor(Date.now() / 1000) + maxAge)
      .sign(secret);

    // Set session cookie
    const cookieStore = await cookies();
    cookieStore.set('session', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      path: '/',
      maxAge,
    });

    // Return user data (without password hash)
    const { passwordHash: _, lockedUntil: __, failedLoginCount: ___, ...userData } = user;

    return successResponse({
      user: userData,
      message: 'Login successful.',
    });
  } catch (error) {
    logger.error('Login error:', error);
    return errorResponse(
      ERROR_CODES.INTERNAL_ERROR,
      'An error occurred during login. Please try again.',
      500
    );
  }
}
